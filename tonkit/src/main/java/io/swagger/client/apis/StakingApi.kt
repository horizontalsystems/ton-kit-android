/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.infrastructure.ApiClient
import io.swagger.client.infrastructure.ClientError
import io.swagger.client.infrastructure.ClientException
import io.swagger.client.infrastructure.MultiValueMap
import io.swagger.client.infrastructure.RequestConfig
import io.swagger.client.infrastructure.RequestMethod
import io.swagger.client.infrastructure.ResponseType
import io.swagger.client.infrastructure.ServerError
import io.swagger.client.infrastructure.ServerException
import io.swagger.client.infrastructure.Success
import io.swagger.client.models.AccountStaking
import io.swagger.client.models.InlineResponse2004
import io.swagger.client.models.InlineResponse2005
import io.swagger.client.models.InlineResponse2006

class StakingApi(basePath: kotlin.String = "https://tonapi.io") : ApiClient(basePath) {

    /**
     * 
     * All pools where account participates
     * @param accountId account ID 
     * @return AccountStaking
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountNominatorsPools(accountId: kotlin.String): AccountStaking {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/staking/nominator/{account_id}/pools".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<AccountStaking>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountStaking
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Pool history
     * @param accountId account ID 
     * @return InlineResponse2005
     */
    @Suppress("UNCHECKED_CAST")
    fun getStakingPoolHistory(accountId: kotlin.String): InlineResponse2005 {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/staking/pool/{account_id}/history".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<InlineResponse2005>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InlineResponse2005
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Stacking pool info
     * @param accountId account ID 
     * @param acceptLanguage  (optional, default to en)
     * @return InlineResponse2004
     */
    @Suppress("UNCHECKED_CAST")
    fun getStakingPoolInfo(accountId: kotlin.String, acceptLanguage: kotlin.String? = null): InlineResponse2004 {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/staking/pool/{account_id}".replace("{" + "account_id" + "}", "$accountId"), headers = localVariableHeaders
        )
        val response = request<InlineResponse2004>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InlineResponse2004
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * All pools available in network
     * @param availableFor account ID (optional)
     * @param includeUnverified return also pools not from white list - just compatible by interfaces (maybe dangerous!) (optional)
     * @param acceptLanguage  (optional, default to en)
     * @return InlineResponse2006
     */
    @Suppress("UNCHECKED_CAST")
    fun getStakingPools(availableFor: kotlin.String? = null, includeUnverified: kotlin.Boolean? = null, acceptLanguage: kotlin.String? = null): InlineResponse2006 {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (availableFor != null) {
                put("available_for", listOf(availableFor.toString()))
            }
            if (includeUnverified != null) {
                put("include_unverified", listOf(includeUnverified.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/staking/pools", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<InlineResponse2006>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InlineResponse2006
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
