/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.infrastructure.ApiClient
import io.swagger.client.infrastructure.ClientError
import io.swagger.client.infrastructure.ClientException
import io.swagger.client.infrastructure.MultiValueMap
import io.swagger.client.infrastructure.RequestConfig
import io.swagger.client.infrastructure.RequestMethod
import io.swagger.client.infrastructure.ResponseType
import io.swagger.client.infrastructure.ServerError
import io.swagger.client.infrastructure.ServerException
import io.swagger.client.infrastructure.Success
import io.swagger.client.models.Event

class EventsApi(basePath: kotlin.String = "https://tonapi.io") : ApiClient(basePath) {

    /**
     * 
     * Emulate sending message to blockchain
     * @param body bag-of-cells serialized to hex 
     * @param acceptLanguage  (optional, default to en)
     * @param ignoreSignatureCheck  (optional)
     * @return Event
     */
    @Suppress("UNCHECKED_CAST")
    fun emulateMessageToEvent(body: kotlin.Any, acceptLanguage: kotlin.String? = null, ignoreSignatureCheck: kotlin.Boolean? = null): Event {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (ignoreSignatureCheck != null) {
                put("ignore_signature_check", listOf(ignoreSignatureCheck.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/v2/events/emulate", query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<Event>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Event
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param eventId event ID or transaction hash in hex (without 0x) or base64url format 
     * @param acceptLanguage  (optional, default to en)
     * @return Event
     */
    @Suppress("UNCHECKED_CAST")
    fun getEvent(eventId: kotlin.String, acceptLanguage: kotlin.String? = null): Event {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/events/{event_id}".replace("{" + "event_id" + "}", "$eventId"), headers = localVariableHeaders
        )
        val response = request<Event>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Event
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
