/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.infrastructure.ApiClient
import io.swagger.client.infrastructure.ClientError
import io.swagger.client.infrastructure.ClientException
import io.swagger.client.infrastructure.MultiValueMap
import io.swagger.client.infrastructure.RequestConfig
import io.swagger.client.infrastructure.RequestMethod
import io.swagger.client.infrastructure.ResponseType
import io.swagger.client.infrastructure.ServerError
import io.swagger.client.infrastructure.ServerException
import io.swagger.client.infrastructure.Success
import io.swagger.client.models.Event
import io.swagger.client.models.JettonHolders
import io.swagger.client.models.JettonInfo
import io.swagger.client.models.JettonTransferPayload
import io.swagger.client.models.Jettons

class JettonsApi(basePath: kotlin.String = "https://tonapi.io") : ApiClient(basePath) {

    /**
     * 
     * Get jetton&#x27;s holders
     * @param accountId account ID 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return JettonHolders
     */
    @Suppress("UNCHECKED_CAST")
    fun getJettonHolders(accountId: kotlin.String, limit: kotlin.Int? = null, offset: kotlin.Int? = null): JettonHolders {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
            if (offset != null) {
                put("offset", listOf(offset.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/jettons/{account_id}/holders".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<JettonHolders>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as JettonHolders
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get jetton metadata by jetton master address
     * @param accountId account ID 
     * @return JettonInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun getJettonInfo(accountId: kotlin.String): JettonInfo {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/jettons/{account_id}".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<JettonInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as JettonInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get jetton&#x27;s custom payload and state init required for transfer
     * @param accountId account ID 
     * @param jettonId jetton ID 
     * @return JettonTransferPayload
     */
    @Suppress("UNCHECKED_CAST")
    fun getJettonTransferPayload(accountId: kotlin.String, jettonId: kotlin.String): JettonTransferPayload {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/jettons/{jetton_id}/transfer/{account_id}/payload".replace("{" + "account_id" + "}", "$accountId").replace("{" + "jetton_id" + "}", "$jettonId")
        )
        val response = request<JettonTransferPayload>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as JettonTransferPayload
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get a list of all indexed jetton masters in the blockchain.
     * @param limit  (optional, default to 100)
     * @param offset  (optional, default to 0)
     * @return Jettons
     */
    @Suppress("UNCHECKED_CAST")
    fun getJettons(limit: kotlin.Int? = null, offset: kotlin.Int? = null): Jettons {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
            if (offset != null) {
                put("offset", listOf(offset.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/jettons", query = localVariableQuery
        )
        val response = request<Jettons>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Jettons
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get only jetton transfers in the event
     * @param eventId event ID or transaction hash in hex (without 0x) or base64url format 
     * @param acceptLanguage  (optional, default to en)
     * @return Event
     */
    @Suppress("UNCHECKED_CAST")
    fun getJettonsEvents(eventId: kotlin.String, acceptLanguage: kotlin.String? = null): Event {
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/events/{event_id}/jettons".replace("{" + "event_id" + "}", "$eventId"), headers = localVariableHeaders
        )
        val response = request<Event>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Event
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
