/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.infrastructure.ApiClient
import io.swagger.client.infrastructure.ClientError
import io.swagger.client.infrastructure.ClientException
import io.swagger.client.infrastructure.MultiValueMap
import io.swagger.client.infrastructure.RequestConfig
import io.swagger.client.infrastructure.RequestMethod
import io.swagger.client.infrastructure.ResponseType
import io.swagger.client.infrastructure.ServerError
import io.swagger.client.infrastructure.ServerException
import io.swagger.client.infrastructure.Success
import io.swagger.client.models.AccountEvents
import io.swagger.client.models.NftCollection
import io.swagger.client.models.NftCollections
import io.swagger.client.models.NftItem
import io.swagger.client.models.NftItems

class NFTApi(basePath: kotlin.String = "https://tonapi.io") : ApiClient(basePath) {

    /**
     * 
     * Get the transfer nft history
     * @param accountId account ID 
     * @param limit  
     * @param acceptLanguage  (optional, default to en)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountNftHistory(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = null, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null): AccountEvents {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            put("limit", listOf(limit.toString()))
            if (startDate != null) {
                put("start_date", listOf(startDate.toString()))
            }
            if (endDate != null) {
                put("end_date", listOf(endDate.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/nfts/history".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvents>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvents
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get NFT items from collection by collection address
     * @param accountId account ID 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return NftItems
     */
    @Suppress("UNCHECKED_CAST")
    fun getItemsFromCollection(accountId: kotlin.String, limit: kotlin.Int? = null, offset: kotlin.Int? = null): NftItems {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
            if (offset != null) {
                put("offset", listOf(offset.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/nfts/collections/{account_id}/items".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<NftItems>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NftItems
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get NFT collection by collection address
     * @param accountId account ID 
     * @return NftCollection
     */
    @Suppress("UNCHECKED_CAST")
    fun getNftCollection(accountId: kotlin.String): NftCollection {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/nfts/collections/{account_id}".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<NftCollection>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NftCollection
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get NFT collections
     * @param limit  (optional, default to 100)
     * @param offset  (optional, default to 0)
     * @return NftCollections
     */
    @Suppress("UNCHECKED_CAST")
    fun getNftCollections(limit: kotlin.Int? = null, offset: kotlin.Int? = null): NftCollections {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
            if (offset != null) {
                put("offset", listOf(offset.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/nfts/collections", query = localVariableQuery
        )
        val response = request<NftCollections>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NftCollections
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get the transfer nfts history for account
     * @param accountId account ID 
     * @param limit  
     * @param acceptLanguage  (optional, default to en)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     */
    @Suppress("UNCHECKED_CAST")
    fun getNftHistoryByID(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = null, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null): AccountEvents {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            put("limit", listOf(limit.toString()))
            if (startDate != null) {
                put("start_date", listOf(startDate.toString()))
            }
            if (endDate != null) {
                put("end_date", listOf(endDate.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/nfts/{account_id}/history".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvents>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvents
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get NFT item by its address
     * @param accountId account ID 
     * @return NftItem
     */
    @Suppress("UNCHECKED_CAST")
    fun getNftItemByAddress(accountId: kotlin.String): NftItem {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/nfts/{account_id}".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<NftItem>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NftItem
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get NFT items by their addresses
     * @param body a list of account ids (optional)
     * @return NftItems
     */
    @Suppress("UNCHECKED_CAST")
    fun getNftItemsByAddresses(body: kotlin.Any? = null): NftItems {
        val localVariableBody: kotlin.Any? = body
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/v2/nfts/_bulk"
        )
        val response = request<NftItems>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NftItems
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
