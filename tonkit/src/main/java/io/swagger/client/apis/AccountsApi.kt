/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.infrastructure.ApiClient
import io.swagger.client.infrastructure.ClientError
import io.swagger.client.infrastructure.ClientException
import io.swagger.client.infrastructure.MultiValueMap
import io.swagger.client.infrastructure.RequestConfig
import io.swagger.client.infrastructure.RequestMethod
import io.swagger.client.infrastructure.ResponseType
import io.swagger.client.infrastructure.ServerError
import io.swagger.client.infrastructure.ServerException
import io.swagger.client.infrastructure.Success
import io.swagger.client.infrastructure.toMultiValue
import io.swagger.client.models.Account
import io.swagger.client.models.AccountEvent
import io.swagger.client.models.AccountEvents
import io.swagger.client.models.Accounts
import io.swagger.client.models.DnsExpiring
import io.swagger.client.models.DomainNames
import io.swagger.client.models.FoundAccounts
import io.swagger.client.models.InlineResponse2001
import io.swagger.client.models.InlineResponse2002
import io.swagger.client.models.JettonBalance
import io.swagger.client.models.JettonsBalances
import io.swagger.client.models.Multisigs
import io.swagger.client.models.NftItems
import io.swagger.client.models.Subscriptions
import io.swagger.client.models.TraceIDs

class AccountsApi(basePath: kotlin.String = "https://tonapi.io") : ApiClient(basePath) {

    /**
     * 
     * Get account&#x27;s domains
     * @param accountId account ID 
     * @return DomainNames
     */
    @Suppress("UNCHECKED_CAST")
    fun accountDnsBackResolve(accountId: kotlin.String): DomainNames {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/dns/backresolve".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<DomainNames>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DomainNames
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Emulate sending message to blockchain
     * @param body bag-of-cells serialized to hex 
     * @param accountId account ID 
     * @param acceptLanguage  (optional, default to en)
     * @param ignoreSignatureCheck  (optional)
     * @return AccountEvent
     */
    @Suppress("UNCHECKED_CAST")
    fun emulateMessageToAccountEvent(body: kotlin.Any, accountId: kotlin.String, acceptLanguage: kotlin.String? = null, ignoreSignatureCheck: kotlin.Boolean? = null): AccountEvent {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (ignoreSignatureCheck != null) {
                put("ignore_signature_check", listOf(ignoreSignatureCheck.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/v2/accounts/{account_id}/events/emulate".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvent>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvent
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get human-friendly information about an account without low-level details.
     * @param accountId account ID 
     * @return Account
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccount(accountId: kotlin.String): Account {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<Account>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Account
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get account&#x27;s balance change
     * @param accountId account ID 
     * @param startDate  
     * @param endDate  
     * @return InlineResponse2002
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountDiff(accountId: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long): InlineResponse2002 {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            put("start_date", listOf(startDate.toString()))
            put("end_date", listOf(endDate.toString()))
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/diff".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<InlineResponse2002>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InlineResponse2002
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get expiring account .ton dns
     * @param accountId account ID 
     * @param period number of days before expiration (optional)
     * @return DnsExpiring
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountDnsExpiring(accountId: kotlin.String, period: kotlin.Int? = null): DnsExpiring {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (period != null) {
                put("period", listOf(period.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/dns/expiring".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<DnsExpiring>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DnsExpiring
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get event for an account by event_id
     * @param accountId account ID 
     * @param eventId event ID or transaction hash in hex (without 0x) or base64url format 
     * @param acceptLanguage  (optional, default to en)
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @return AccountEvent
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountEvent(accountId: kotlin.String, eventId: kotlin.String, acceptLanguage: kotlin.String? = null, subjectOnly: kotlin.Boolean? = null): AccountEvent {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (subjectOnly != null) {
                put("subject_only", listOf(subjectOnly.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/events/{event_id}".replace("{" + "account_id" + "}", "$accountId").replace("{" + "event_id" + "}", "$eventId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvent>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvent
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
     * @param accountId account ID 
     * @param limit  
     * @param acceptLanguage  (optional, default to en)
     * @param initiator Show only events that are initiated by this account (optional, default to false)
     * @param subjectOnly filter actions where requested account is not real subject (for example sender or receiver jettons) (optional, default to false)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountEvents(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = null, initiator: kotlin.Boolean? = null, subjectOnly: kotlin.Boolean? = null, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null): AccountEvents {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (initiator != null) {
                put("initiator", listOf(initiator.toString()))
            }
            if (subjectOnly != null) {
                put("subject_only", listOf(subjectOnly.toString()))
            }
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            put("limit", listOf(limit.toString()))
            if (startDate != null) {
                put("start_date", listOf(startDate.toString()))
            }
            if (endDate != null) {
                put("end_date", listOf(endDate.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/events".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvents>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvents
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get Jetton balance by owner address
     * @param accountId account ID 
     * @param jettonId jetton ID 
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @param supportedExtensions comma separated list supported extensions (optional)
     * @return JettonBalance
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountJettonBalance(accountId: kotlin.String, jettonId: kotlin.String, currencies: kotlin.Array<kotlin.String>? = null, supportedExtensions: kotlin.Array<kotlin.String>? = null): JettonBalance {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (currencies != null) {
                put("currencies", toMultiValue(currencies.toList(), "csv"))
            }
            if (supportedExtensions != null) {
                put("supported_extensions", toMultiValue(supportedExtensions.toList(), "csv"))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/jettons/{jetton_id}".replace("{" + "account_id" + "}", "$accountId").replace("{" + "jetton_id" + "}", "$jettonId"), query = localVariableQuery
        )
        val response = request<JettonBalance>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as JettonBalance
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get the transfer jetton history for account and jetton
     * @param accountId account ID 
     * @param jettonId jetton ID 
     * @param limit  
     * @param acceptLanguage  (optional, default to en)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountJettonHistoryByID(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = null, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null): AccountEvents {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            put("limit", listOf(limit.toString()))
            if (startDate != null) {
                put("start_date", listOf(startDate.toString()))
            }
            if (endDate != null) {
                put("end_date", listOf(endDate.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/jettons/{jetton_id}/history".replace("{" + "account_id" + "}", "$accountId").replace("{" + "jetton_id" + "}", "$jettonId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvents>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvents
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get all Jettons balances by owner address
     * @param accountId account ID 
     * @param currencies accept ton and all possible fiat currencies, separated by commas (optional)
     * @param supportedExtensions comma separated list supported extensions (optional)
     * @return JettonsBalances
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountJettonsBalances(accountId: kotlin.String, currencies: kotlin.Array<kotlin.String>? = null, supportedExtensions: kotlin.Array<kotlin.String>? = null): JettonsBalances {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (currencies != null) {
                put("currencies", toMultiValue(currencies.toList(), "csv"))
            }
            if (supportedExtensions != null) {
                put("supported_extensions", toMultiValue(supportedExtensions.toList(), "csv"))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/jettons".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<JettonsBalances>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as JettonsBalances
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get the transfer jettons history for account
     * @param accountId account ID 
     * @param limit  
     * @param acceptLanguage  (optional, default to en)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param startDate  (optional)
     * @param endDate  (optional)
     * @return AccountEvents
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountJettonsHistory(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = null, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null): AccountEvents {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            put("limit", listOf(limit.toString()))
            if (startDate != null) {
                put("start_date", listOf(startDate.toString()))
            }
            if (endDate != null) {
                put("end_date", listOf(endDate.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/jettons/history".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvents>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvents
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get account&#x27;s multisigs
     * @param accountId account ID 
     * @return Multisigs
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountMultisigs(accountId: kotlin.String): Multisigs {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/multisigs".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<Multisigs>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Multisigs
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get all NFT items by owner address
     * @param accountId account ID 
     * @param collection nft collection (optional)
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @param indirectOwnership Selling nft items in ton implemented usually via transfer items to special selling account. This option enables including items which owned not directly. (optional, default to false)
     * @return NftItems
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountNftItems(accountId: kotlin.String, collection: kotlin.String? = null, limit: kotlin.Int? = null, offset: kotlin.Int? = null, indirectOwnership: kotlin.Boolean? = null): NftItems {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (collection != null) {
                put("collection", listOf(collection.toString()))
            }
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
            if (offset != null) {
                put("offset", listOf(offset.toString()))
            }
            if (indirectOwnership != null) {
                put("indirect_ownership", listOf(indirectOwnership.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/nfts".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<NftItems>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as NftItems
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get public key by account id
     * @param accountId account ID 
     * @return InlineResponse2001
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountPublicKey(accountId: kotlin.String): InlineResponse2001 {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/publickey".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<InlineResponse2001>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InlineResponse2001
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get all subscriptions by wallet address
     * @param accountId account ID 
     * @return Subscriptions
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountSubscriptions(accountId: kotlin.String): Subscriptions {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/subscriptions".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<Subscriptions>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Subscriptions
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get traces for account
     * @param accountId account ID 
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return TraceIDs
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountTraces(accountId: kotlin.String, beforeLt: kotlin.Long? = null, limit: kotlin.Int? = null): TraceIDs {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/{account_id}/traces".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<TraceIDs>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as TraceIDs
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get human-friendly information about several accounts without low-level details.
     * @param body a list of account ids (optional)
     * @param currency  (optional)
     * @return Accounts
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccounts(body: kotlin.Any? = null, currency: kotlin.String? = null): Accounts {
        val localVariableBody: kotlin.Any? = body
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (currency != null) {
                put("currency", listOf(currency.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/v2/accounts/_bulk", query = localVariableQuery
        )
        val response = request<Accounts>(
                localVariableConfig, localVariableBody
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Accounts
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Update internal cache for a particular account
     * @param accountId account ID 
     * @return void
     */
    fun reindexAccount(accountId: kotlin.String): Unit {
        val localVariableConfig = RequestConfig(
                RequestMethod.POST,
                "/v2/accounts/{account_id}/reindex".replace("{" + "account_id" + "}", "$accountId")
        )
        val response = request<Any?>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Search by account domain name
     * @param name  
     * @return FoundAccounts
     */
    @Suppress("UNCHECKED_CAST")
    fun searchAccounts(name: kotlin.String): FoundAccounts {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            put("name", listOf(name.toString()))
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/accounts/search", query = localVariableQuery
        )
        val response = request<FoundAccounts>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as FoundAccounts
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
