/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.infrastructure.ApiClient
import io.swagger.client.infrastructure.ClientError
import io.swagger.client.infrastructure.ClientException
import io.swagger.client.infrastructure.MultiValueMap
import io.swagger.client.infrastructure.RequestConfig
import io.swagger.client.infrastructure.RequestMethod
import io.swagger.client.infrastructure.ResponseType
import io.swagger.client.infrastructure.ServerError
import io.swagger.client.infrastructure.ServerException
import io.swagger.client.infrastructure.Success
import io.swagger.client.models.Auctions
import io.swagger.client.models.DnsRecord
import io.swagger.client.models.DomainBids
import io.swagger.client.models.DomainInfo

class DNSApi(basePath: kotlin.String = "https://tonapi.io") : ApiClient(basePath) {

    /**
     * 
     * DNS resolve for domain name
     * @param domainName domain name with .ton or .t.me 
     * @return DnsRecord
     */
    @Suppress("UNCHECKED_CAST")
    fun dnsResolve(domainName: kotlin.String): DnsRecord {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/dns/{domain_name}/resolve".replace("{" + "domain_name" + "}", "$domainName")
        )
        val response = request<DnsRecord>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DnsRecord
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get all auctions
     * @param tld domain filter for current auctions \&quot;ton\&quot; or \&quot;t.me\&quot; (optional)
     * @return Auctions
     */
    @Suppress("UNCHECKED_CAST")
    fun getAllAuctions(tld: kotlin.String? = null): Auctions {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (tld != null) {
                put("tld", listOf(tld.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/dns/auctions", query = localVariableQuery
        )
        val response = request<Auctions>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as Auctions
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get full information about domain name
     * @param domainName domain name with .ton or .t.me 
     * @return DomainInfo
     */
    @Suppress("UNCHECKED_CAST")
    fun getDnsInfo(domainName: kotlin.String): DomainInfo {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/dns/{domain_name}".replace("{" + "domain_name" + "}", "$domainName")
        )
        val response = request<DomainInfo>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DomainInfo
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get domain bids
     * @param domainName domain name with .ton or .t.me 
     * @return DomainBids
     */
    @Suppress("UNCHECKED_CAST")
    fun getDomainBids(domainName: kotlin.String): DomainBids {
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/dns/{domain_name}/bids".replace("{" + "domain_name" + "}", "$domainName")
        )
        val response = request<DomainBids>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as DomainBids
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
