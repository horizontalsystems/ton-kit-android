/**
 * REST api to TON blockchain explorer
 * Provide access to indexed TON blockchain
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@tonkeeper.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
package io.swagger.client.apis

import io.swagger.client.infrastructure.ApiClient
import io.swagger.client.infrastructure.ClientError
import io.swagger.client.infrastructure.ClientException
import io.swagger.client.infrastructure.MultiValueMap
import io.swagger.client.infrastructure.RequestConfig
import io.swagger.client.infrastructure.RequestMethod
import io.swagger.client.infrastructure.ResponseType
import io.swagger.client.infrastructure.ServerError
import io.swagger.client.infrastructure.ServerException
import io.swagger.client.infrastructure.Success
import io.swagger.client.models.AccountEvents
import io.swagger.client.models.InlineResponse2003
import io.swagger.client.models.InscriptionBalances

class InscriptionsApi(basePath: kotlin.String = "https://tonapi.io") : ApiClient(basePath) {

    /**
     * 
     * Get all inscriptions by owner address. It&#x27;s experimental API and can be dropped in the future.
     * @param accountId account ID 
     * @param limit  (optional, default to 1000)
     * @param offset  (optional, default to 0)
     * @return InscriptionBalances
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountInscriptions(accountId: kotlin.String, limit: kotlin.Int? = null, offset: kotlin.Int? = null): InscriptionBalances {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
            if (offset != null) {
                put("offset", listOf(offset.toString()))
            }
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/experimental/accounts/{account_id}/inscriptions".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery
        )
        val response = request<InscriptionBalances>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InscriptionBalances
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get the transfer inscriptions history for account. It&#x27;s experimental API and can be dropped in the future.
     * @param accountId account ID 
     * @param acceptLanguage  (optional, default to en)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return AccountEvents
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountInscriptionsHistory(accountId: kotlin.String, acceptLanguage: kotlin.String? = null, beforeLt: kotlin.Long? = null, limit: kotlin.Int? = null): AccountEvents {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/experimental/accounts/{account_id}/inscriptions/history".replace("{" + "account_id" + "}", "$accountId"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvents>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvents
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * Get the transfer inscriptions history for account. It&#x27;s experimental API and can be dropped in the future.
     * @param accountId account ID 
     * @param ticker  
     * @param acceptLanguage  (optional, default to en)
     * @param beforeLt omit this parameter to get last events (optional)
     * @param limit  (optional, default to 100)
     * @return AccountEvents
     */
    @Suppress("UNCHECKED_CAST")
    fun getAccountInscriptionsHistoryByTicker(accountId: kotlin.String, ticker: kotlin.String, acceptLanguage: kotlin.String? = null, beforeLt: kotlin.Long? = null, limit: kotlin.Int? = null): AccountEvents {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            if (beforeLt != null) {
                put("before_lt", listOf(beforeLt.toString()))
            }
            if (limit != null) {
                put("limit", listOf(limit.toString()))
            }
        }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply {
            localVariableHeaders["Accept-Language"] = this.toString()
        }
        localVariableHeaders["Accept"] = "application/json"
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/experimental/accounts/{account_id}/inscriptions/{ticker}/history".replace("{" + "account_id" + "}", "$accountId").replace("{" + "ticker" + "}", "$ticker"), query = localVariableQuery, headers = localVariableHeaders
        )
        val response = request<AccountEvents>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as AccountEvents
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
    /**
     * 
     * return comment for making operation with inscription. please don&#x27;t use it if you don&#x27;t know what you are doing
     * @param type  
     * @param operation  
     * @param amount  
     * @param ticker  
     * @param who  
     * @param destination  (optional)
     * @param comment  (optional)
     * @return InlineResponse2003
     */
    @Suppress("UNCHECKED_CAST")
    fun getInscriptionOpTemplate(type: kotlin.String, operation: kotlin.String, amount: kotlin.String, ticker: kotlin.String, who: kotlin.String, destination: kotlin.String? = null, comment: kotlin.String? = null): InlineResponse2003 {
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>().apply {
            put("type", listOf(type.toString()))
            if (destination != null) {
                put("destination", listOf(destination.toString()))
            }
            if (comment != null) {
                put("comment", listOf(comment.toString()))
            }
            put("operation", listOf(operation.toString()))
            put("amount", listOf(amount.toString()))
            put("ticker", listOf(ticker.toString()))
            put("who", listOf(who.toString()))
        }
        val localVariableConfig = RequestConfig(
                RequestMethod.GET,
                "/v2/experimental/inscriptions/op-template", query = localVariableQuery
        )
        val response = request<InlineResponse2003>(
                localVariableConfig
        )

        return when (response.responseType) {
            ResponseType.Success -> (response as Success<*>).data as InlineResponse2003
            ResponseType.Informational -> TODO()
            ResponseType.Redirection -> TODO()
            ResponseType.ClientError -> throw ClientException((response as ClientError<*>).body as? String ?: "Client error")
            ResponseType.ServerError -> throw ServerException((response as ServerError<*>).message ?: "Server error")
        }
    }
}
